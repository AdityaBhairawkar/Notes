## ğŸ”¹ **1. ClusterIP (Default)**

ğŸ”¸ **Use Case:** Internal communication within the cluster.  
ğŸ”¸ **Access:** Only accessible **inside** the cluster (not from the external network).  
ğŸ”¸ **Default Type:** If no type is specified, Kubernetes assigns **ClusterIP**.

### âœ… **Example YAML for ClusterIP Service**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-clusterip-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80        # Service Port
      targetPort: 8080  # Container Port
  type: ClusterIP
```

### ğŸ” **How to Access?**

```sh
kubectl get services
curl http://<CLUSTER_IP>:80   # Only works inside the cluster
```

---

## ğŸ”¹ **2. NodePort**

ğŸ”¸ **Use Case:** Exposes the service on a **high port (30000-32767)** on each **Nodeâ€™s IP**.  
ğŸ”¸ **Access:** Can be accessed **externally** via `<NodeIP>:<NodePort>`.  
ğŸ”¸ **Limitations:** Not suitable for production (ports are limited and hard to manage).

### âœ… **Example YAML for NodePort Service**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-nodeport-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
      nodePort: 30007  # Exposes on this NodePort
  type: NodePort
```

### ğŸ” **How to Access?**

```sh
kubectl get services
curl http://<NodeIP>:30007  # Accessible from outside the cluster
```

---

## ğŸ”¹ **3. LoadBalancer**

ğŸ”¸ **Use Case:** Exposes the service to the **internet** via a **cloud providerâ€™s Load Balancer** (AWS, GCP, Azure).  
ğŸ”¸ **Access:** Automatically assigns an **external IP** to the service.  
ğŸ”¸ **Best for:** Production environments with **cloud-managed** clusters.

### âœ… **Example YAML for LoadBalancer Service**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-loadbalancer-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: LoadBalancer
```

### ğŸ” **How to Access?**

```sh
kubectl get services
curl http://<EXTERNAL-IP>:80  # Accessible from anywhere
```

---


|Service Type|Access Scope|External IP?|Use Case|
|---|---|---|---|
|**ClusterIP**|Internal Cluster Only|âŒ No|Internal microservices communication|
|**NodePort**|Any Nodeâ€™s IP|âš ï¸ Yes (on a high port)|Basic external access, debugging|
|**LoadBalancer**|Public Internet|âœ… Yes (via cloud LB)|Production, internet-facing apps|


## ğŸ”¹ **1. Using a Service (Recommended)**

Pods are **ephemeral**, so directly accessing them is not reliable. Instead, expose them using a **Kubernetes Service**:

### âœ… **Options:**

|Service Type|Access Scope|How to Access?|
|---|---|---|
|**ClusterIP** (default)|Internal only|Cannot access from outside|
|**NodePort**|Any nodeâ€™s IP|`<NodeIP>:<NodePort>`|
|**LoadBalancer**|Public internet|`<ExternalIP>:<Port>`|

---

### **ğŸ”¹ Option 1: Expose with a NodePort Service**

ğŸ“Œ **Use case:** If you want access via any **nodeâ€™s IP** and a high port.

#### **YAML Example:**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-nodeport-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80        # Service port
      targetPort: 8080 # Container port
      nodePort: 30007  # External port on the node
  type: NodePort
```

#### **Access:**

```sh
kubectl get services
curl http://<NodeIP>:30007  # Accessible externally
```

---

### **ğŸ”¹ Option 2: Expose with a LoadBalancer Service**

ğŸ“Œ **Use case:** If you are on **cloud providers** like AWS, GCP, or Azure.

#### **YAML Example:**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-loadbalancer-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: LoadBalancer
```

#### **Access:**

```sh
kubectl get services
curl http://<EXTERNAL-IP>:80  # Accessible from anywhere
```

---

## ğŸ”¹ **2. Using Port Forwarding (For Debugging)**

ğŸ“Œ **Use case:** If you only need temporary access for debugging.

#### **Command:**

```sh
kubectl port-forward pod/<pod-name> 8080:80
```

#### **Access:**

```sh
curl http://localhost:8080
```

**âš ï¸ Note:** This works **only on your local machine**.

---

## ğŸ”¹ **3. Using an Ingress Controller (For HTTP/HTTPS Traffic)**

ğŸ“Œ **Use case:** If you want to **route traffic based on URLs**.

#### **YAML Example:**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
spec:
  rules:
    - host: myapp.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: my-service
                port:
                  number: 80
```

#### **Access:**

```sh
curl http://myapp.example.com
```

**âš ï¸ Requires an Ingress Controller** (e.g., NGINX Ingress, Traefik).

---

|Access Method|Use Case|
|---|---|
|**NodePort**|Small-scale, quick access via `<NodeIP>:<Port>`|
|**LoadBalancer**|Production, cloud-based external access|
|**Port Forwarding**|Debugging on local machine|
|**Ingress**|Managing multiple services with URLs|

## ğŸ”¹ **What is a Namespace in Kubernetes?**

A **Namespace** in Kubernetes is a **logical partition** that allows you to create **isolated environments** within a cluster. It helps in **organizing** and **managing resources** for different teams, applications, or projects.

### **ğŸ”¹ Why Use Namespaces?**

âœ”ï¸ **Multi-tenancy:** Different teams can work in the same cluster without conflict.  
âœ”ï¸ **Resource Isolation:** Limits CPU, memory, and storage for different groups.  
âœ”ï¸ **Access Control:** RBAC (Role-Based Access Control) can be applied per namespace.  
âœ”ï¸ **Organization:** Separate dev, staging, and production environments.

---

## ğŸ”¹ **How to Create a Namespace?**

### âœ… **Method 1: Using `kubectl` Command**

```sh
kubectl create namespace my-namespace
```

**Verify:**

```sh
kubectl get namespaces
```

---

### âœ… **Method 2: Using a YAML File**

ğŸ“Œ **Create a file `namespace.yaml`:**

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: my-namespace
```

**Apply the YAML:**

```sh
kubectl apply -f namespace.yaml
```

**Verify:**

```sh
kubectl get namespaces
```

---

## ğŸ”¹ **Using a Namespace in Kubernetes**

### âœ… **Run a Pod in a Specific Namespace**

```sh
kubectl run nginx --image=nginx --namespace=my-namespace
```

### âœ… **List Resources in a Specific Namespace**

```sh
kubectl get pods -n my-namespace
```

### âœ… **Set Default Namespace for a Context**

```sh
kubectl config set-context --current --namespace=my-namespace
```

---

|Feature|Description|
|---|---|
|**Default Namespace**|If no namespace is specified, resources go to the `default` namespace.|
|**System Namespaces**|`kube-system` (for system components), `kube-public` (public resources).|
|**Resource Quotas**|You can limit CPU, memory, and storage per namespace.|

Namespaces help in **scaling** and **organizing** Kubernetes clusters efficiently! ğŸš€ Let me know if you need more details. ğŸ”¥